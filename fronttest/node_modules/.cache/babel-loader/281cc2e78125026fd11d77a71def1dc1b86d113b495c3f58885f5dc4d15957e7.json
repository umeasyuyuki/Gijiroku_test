{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, ConstantSourceNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n  const {\n    encoderId,\n    port\n  } = await instantiate(mimeType, audioContext.sampleRate);\n  if (AudioWorkletNode === undefined) {\n    throw new Error(ERROR_MESSAGE);\n  }\n  const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n    buffer: audioBuffer\n  });\n  const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n    mediaStream\n  });\n  const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n    channelCount\n  });\n  return {\n    audioBufferSourceNode,\n    encoderId,\n    mediaStreamAudioSourceNode,\n    port,\n    recorderAudioWorkletNode\n  };\n};\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    var _a;\n    const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    const audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate\n    });\n    const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    const audioBuffer = new AudioBuffer({\n      length,\n      sampleRate: audioContext.sampleRate\n    });\n    const bufferedArrayBuffers = [];\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule(url => {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n      return addAudioWorkletModule(audioContext, url);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderId = null;\n    let promisedPartialRecording = null;\n    let isAudioContextRunning = true;\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n      if (promisedAudioNodesAndEncoderId === null) {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n    const resume = () => {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n      promisedAudioNodesAndEncoderId.then(async ({\n        constantSourceNode,\n        encoderId,\n        mediaStreamAudioSourceNode,\n        recorderAudioWorkletNode\n      }) => {\n        if (promisedPartialRecording !== null) {\n          promisedPartialRecording.catch(() => {\n            /* @todo Only catch the errors caused by a duplicate call to encode. */\n          });\n          promisedPartialRecording = null;\n        }\n        await recorderAudioWorkletNode.stop();\n        mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n        constantSourceNode.stop();\n        const arrayBuffers = await encode(encoderId, null);\n        if (promisedAudioNodesAndEncoderId === null) {\n          await suspend();\n        }\n        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n        bufferedArrayBuffers.length = 0;\n        eventTarget.dispatchEvent(new Event('stop'));\n      });\n      promisedAudioNodesAndEncoderId = null;\n    };\n    const suspend = () => {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n      pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n      resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n        if (!isAudioContextRunning) {\n          resume();\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n      start(timeslice) {\n        var _a;\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        eventTarget.dispatchEvent(new Event('start'));\n        const audioTracks = mediaStream.getAudioTracks();\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([resume(), promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))]).then(async ([, {\n          audioBufferSourceNode,\n          encoderId,\n          mediaStreamAudioSourceNode,\n          port,\n          recorderAudioWorkletNode\n        }]) => {\n          mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n          await new Promise(resolve => {\n            audioBufferSourceNode.onended = resolve;\n            audioBufferSourceNode.connect(recorderAudioWorkletNode);\n            audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n          });\n          audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n          // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n          const constantSourceNode = new ConstantSourceNode(audioContext, {\n            offset: 0\n          });\n          constantSourceNode.onended = () => constantSourceNode.disconnect();\n          constantSourceNode.connect(audioContext.destination);\n          constantSourceNode.start();\n          await recorderAudioWorkletNode.record(port);\n          if (timeslice !== undefined) {\n            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n          }\n          return {\n            constantSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            recorderAudioWorkletNode\n          };\n        });\n        const tracks = mediaStream.getTracks();\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n      stop\n    };\n  };\n};","map":{"version":3,"names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","ConstantSourceNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","encoderId","port","sampleRate","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","_a","getAudioTracks","getSettings","latencyHint","length","Math","max","ceil","baseLatency","bufferedArrayBuffers","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","push","resume","stop","removeEventListener","clearTimeout","then","constantSourceNode","catch","disconnect","suspend","Event","state","pause","start","getVideoTracks","audioTracks","Promise","all","connect","resolve","onended","currentTime","offset","destination","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/extendable-media-recorder/src/factories/web-audio-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    ConstantSourceNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(\n                async ({ constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                    if (promisedPartialRecording !== null) {\n                        promisedPartialRecording.catch(() => {\n                            /* @todo Only catch the errors caused by a duplicate call to encode. */\n                        });\n                        promisedPartialRecording = null;\n                    }\n\n                    await recorderAudioWorkletNode.stop();\n\n                    mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                    constantSourceNode.stop();\n\n                    const arrayBuffers = await encode(encoderId, null);\n\n                    if (promisedAudioNodesAndEncoderId === null) {\n                        await suspend();\n                    }\n\n                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                    bufferedArrayBuffers.length = 0;\n\n                    eventTarget.dispatchEvent(new Event('stop'));\n                }\n            );\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount =\n                    audioTracks.length === 0\n                        ? 2\n                        : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    // Bug #17: Safari does throttle the processing on hidden tabs if there is no active audio output.\n                    const constantSourceNode = new ConstantSourceNode(audioContext, { offset: 0 });\n\n                    constantSourceNode.onended = () => constantSourceNode.disconnect();\n                    constantSourceNode.connect(audioContext.destination);\n                    constantSourceNode.start();\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}