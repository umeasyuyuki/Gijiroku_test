{"ast":null,"code":"export const createDecodeWebMChunk = (readElementContent, readElementType) => {\n  return (dataView, elementType, channelCount) => {\n    const contents = [];\n    let currentElementType = elementType;\n    let offset = 0;\n    while (offset < dataView.byteLength) {\n      if (currentElementType === null) {\n        const lengthAndType = readElementType(dataView, offset);\n        if (lengthAndType === null) {\n          break;\n        }\n        const {\n          length,\n          type\n        } = lengthAndType;\n        currentElementType = type;\n        offset += length;\n      } else {\n        const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n        if (contentAndLength === null) {\n          break;\n        }\n        const {\n          content,\n          length\n        } = contentAndLength;\n        currentElementType = null;\n        offset += length;\n        if (content !== null) {\n          contents.push(content);\n        }\n      }\n    }\n    return {\n      contents,\n      currentElementType,\n      offset\n    };\n  };\n};","map":{"version":3,"names":["createDecodeWebMChunk","readElementContent","readElementType","dataView","elementType","channelCount","contents","currentElementType","offset","byteLength","lengthAndType","length","type","contentAndLength","content","push"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/extendable-media-recorder/src/factories/decode-web-m-chunk.ts"],"sourcesContent":["import { TDecodeWebMChunkFactory } from '../types';\n\nexport const createDecodeWebMChunk: TDecodeWebMChunkFactory = (readElementContent, readElementType) => {\n    return (dataView, elementType, channelCount) => {\n        const contents: (readonly Float32Array[])[] = [];\n\n        let currentElementType = elementType;\n        let offset = 0;\n\n        while (offset < dataView.byteLength) {\n            if (currentElementType === null) {\n                const lengthAndType = readElementType(dataView, offset);\n\n                if (lengthAndType === null) {\n                    break;\n                }\n\n                const { length, type } = lengthAndType;\n\n                currentElementType = type;\n                offset += length;\n            } else {\n                const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n                if (contentAndLength === null) {\n                    break;\n                }\n\n                const { content, length } = contentAndLength;\n\n                currentElementType = null;\n                offset += length;\n\n                if (content !== null) {\n                    contents.push(content);\n                }\n            }\n        }\n\n        return { contents, currentElementType, offset };\n    };\n};\n"],"mappings":"AAEA,OAAO,MAAMA,qBAAqB,GAA4BA,CAACC,kBAAkB,EAAEC,eAAe,KAAI;EAClG,OAAO,CAACC,QAAQ,EAAEC,WAAW,EAAEC,YAAY,KAAI;IAC3C,MAAMC,QAAQ,GAAgC,EAAE;IAEhD,IAAIC,kBAAkB,GAAGH,WAAW;IACpC,IAAII,MAAM,GAAG,CAAC;IAEd,OAAOA,MAAM,GAAGL,QAAQ,CAACM,UAAU,EAAE;MACjC,IAAIF,kBAAkB,KAAK,IAAI,EAAE;QAC7B,MAAMG,aAAa,GAAGR,eAAe,CAACC,QAAQ,EAAEK,MAAM,CAAC;QAEvD,IAAIE,aAAa,KAAK,IAAI,EAAE;UACxB;;QAGJ,MAAM;UAAEC,MAAM;UAAEC;QAAI,CAAE,GAAGF,aAAa;QAEtCH,kBAAkB,GAAGK,IAAI;QACzBJ,MAAM,IAAIG,MAAM;OACnB,MAAM;QACH,MAAME,gBAAgB,GAAGZ,kBAAkB,CAACE,QAAQ,EAAEK,MAAM,EAAED,kBAAkB,EAAEF,YAAY,CAAC;QAE/F,IAAIQ,gBAAgB,KAAK,IAAI,EAAE;UAC3B;;QAGJ,MAAM;UAAEC,OAAO;UAAEH;QAAM,CAAE,GAAGE,gBAAgB;QAE5CN,kBAAkB,GAAG,IAAI;QACzBC,MAAM,IAAIG,MAAM;QAEhB,IAAIG,OAAO,KAAK,IAAI,EAAE;UAClBR,QAAQ,CAACS,IAAI,CAACD,OAAO,CAAC;;;;IAKlC,OAAO;MAAER,QAAQ;MAAEC,kBAAkB;MAAEC;IAAM,CAAE;EACnD,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}