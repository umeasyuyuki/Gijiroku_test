{"ast":null,"code":"export const createNativeMediaRecorderFactory = (createInvalidModificationError, createNotSupportedError) => {\n  return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n    const bufferedBlobs = [];\n    const dataAvailableListeners = new WeakMap();\n    const errorListeners = new WeakMap();\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n    const stopListeners = new WeakMap();\n    let isActive = true;\n    nativeMediaRecorder.addEventListener = (addEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              setTimeout(() => {\n                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                  bufferedBlobs.push(event.data);\n                } else {\n                  if (bufferedBlobs.length > 0) {\n                    const blob = event.data;\n                    Object.defineProperty(event, 'data', {\n                      value: new Blob([...bufferedBlobs, blob], {\n                        type: blob.type\n                      })\n                    });\n                    bufferedBlobs.length = 0;\n                  }\n                  listener.call(nativeMediaRecorder, event);\n                }\n              });\n            };\n            dataAvailableListeners.set(listener, patchedEventListener);\n          } else if (type === 'error') {\n            // Bug #12 & #13: Firefox fires a regular event with an error property.\n            patchedEventListener = event => {\n              // Bug #3 & #4: Chrome throws an error event without any error.\n              if (event.error === undefined) {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError()\n                }));\n                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n              } else if (event.error.name === 'UnknownError') {\n                const message = event.error.message;\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError(message)\n                }));\n              } else if (event instanceof ErrorEvent) {\n                listener.call(nativeMediaRecorder, event);\n              } else {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: event.error\n                }));\n              }\n            };\n            errorListeners.set(listener, patchedEventListener);\n          } else if (type === 'stop') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              isActive = false;\n              setTimeout(() => listener.call(nativeMediaRecorder, event));\n            };\n            stopListeners.set(listener, patchedEventListener);\n          }\n        }\n        return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.addEventListener);\n    nativeMediaRecorder.dispatchEvent = (dispatchEvent => {\n      // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n      return event => {\n        let wasActive;\n        setTimeout(() => {\n          wasActive = isActive;\n          isActive = false;\n        });\n        const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n        setTimeout(() => isActive = wasActive);\n        return returnValue;\n      };\n    })(nativeMediaRecorder.dispatchEvent);\n    nativeMediaRecorder.removeEventListener = (removeEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            const dataAvailableListener = dataAvailableListeners.get(listener);\n            if (dataAvailableListener !== undefined) {\n              patchedEventListener = dataAvailableListener;\n            }\n          } else if (type === 'error') {\n            const errorListener = errorListeners.get(listener);\n            if (errorListener !== undefined) {\n              patchedEventListener = errorListener;\n            }\n          } else if (type === 'stop') {\n            const stopListener = stopListeners.get(listener);\n            if (stopListener !== undefined) {\n              patchedEventListener = stopListener;\n            }\n          }\n        }\n        return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.removeEventListener);\n    nativeMediaRecorder.start = (start => {\n      return timeslice => {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n        isActive = timeslice !== undefined;\n        return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n      };\n    })(nativeMediaRecorder.start);\n    return nativeMediaRecorder;\n  };\n};","map":{"version":3,"names":["createNativeMediaRecorderFactory","createInvalidModificationError","createNotSupportedError","nativeMediaRecorderConstructor","stream","mediaRecorderOptions","bufferedBlobs","dataAvailableListeners","WeakMap","errorListeners","nativeMediaRecorder","stopListeners","isActive","addEventListener","type","listener","options","patchedEventListener","event","setTimeout","state","push","data","length","blob","Object","defineProperty","value","Blob","call","set","error","undefined","ErrorEvent","name","message","dispatchEvent","wasActive","returnValue","removeEventListener","dataAvailableListener","get","errorListener","stopListener","start","timeslice","mimeType","startsWith","getVideoTracks"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/extendable-media-recorder/src/factories/native-media-recorder.ts"],"sourcesContent":["import { IBlobEvent, IMediaRecorder } from '../interfaces';\nimport { TEventHandler, TNativeMediaRecorderFactoryFactory } from '../types';\n\nexport const createNativeMediaRecorderFactory: TNativeMediaRecorderFactoryFactory = (\n    createInvalidModificationError,\n    createNotSupportedError\n) => {\n    return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n        const bufferedBlobs: Blob[] = [];\n        const dataAvailableListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: IBlobEvent) => void>();\n        const errorListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: ErrorEvent) => void>();\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        const stopListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: Event) => void>();\n\n        let isActive = true;\n\n        nativeMediaRecorder.addEventListener = ((addEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | AddEventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: IBlobEvent) => {\n                            setTimeout(() => {\n                                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                                    bufferedBlobs.push(event.data);\n                                } else {\n                                    if (bufferedBlobs.length > 0) {\n                                        const blob = event.data;\n\n                                        Object.defineProperty(event, 'data', {\n                                            value: new Blob([...bufferedBlobs, blob], { type: blob.type })\n                                        });\n\n                                        bufferedBlobs.length = 0;\n                                    }\n\n                                    listener.call(nativeMediaRecorder, event);\n                                }\n                            });\n                        };\n\n                        dataAvailableListeners.set(listener, patchedEventListener);\n                    } else if (type === 'error') {\n                        // Bug #12 & #13: Firefox fires a regular event with an error property.\n                        patchedEventListener = (event: ErrorEvent | (Event & { error?: Error })) => {\n                            // Bug #3 & #4: Chrome throws an error event without any error.\n                            if (event.error === undefined) {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: createInvalidModificationError() }));\n                                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n                            } else if (event.error.name === 'UnknownError') {\n                                const message = event.error.message;\n\n                                listener.call(\n                                    nativeMediaRecorder,\n                                    new ErrorEvent('error', { error: createInvalidModificationError(message) })\n                                );\n                            } else if (event instanceof ErrorEvent) {\n                                listener.call(nativeMediaRecorder, event);\n                            } else {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                            }\n                        };\n\n                        errorListeners.set(listener, patchedEventListener);\n                    } else if (type === 'stop') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: Event) => {\n                            isActive = false;\n\n                            setTimeout(() => listener.call(nativeMediaRecorder, event));\n                        };\n\n                        stopListeners.set(listener, patchedEventListener);\n                    }\n                }\n\n                return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.addEventListener);\n\n        nativeMediaRecorder.dispatchEvent = ((dispatchEvent) => {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            return (event: Event) => {\n                let wasActive: boolean;\n\n                setTimeout(() => {\n                    wasActive = isActive;\n                    isActive = false;\n                });\n\n                const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n\n                setTimeout(() => (isActive = wasActive));\n\n                return returnValue;\n            };\n        })(nativeMediaRecorder.dispatchEvent);\n\n        nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | EventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        const dataAvailableListener = dataAvailableListeners.get(listener);\n\n                        if (dataAvailableListener !== undefined) {\n                            patchedEventListener = dataAvailableListener;\n                        }\n                    } else if (type === 'error') {\n                        const errorListener = errorListeners.get(listener);\n\n                        if (errorListener !== undefined) {\n                            patchedEventListener = errorListener;\n                        }\n                    } else if (type === 'stop') {\n                        const stopListener = stopListeners.get(listener);\n\n                        if (stopListener !== undefined) {\n                            patchedEventListener = stopListener;\n                        }\n                    }\n                }\n\n                return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.removeEventListener);\n\n        nativeMediaRecorder.start = ((start) => {\n            return (timeslice?: number) => {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (\n                    mediaRecorderOptions.mimeType !== undefined &&\n                    mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                    stream.getVideoTracks().length > 0\n                ) {\n                    throw createNotSupportedError();\n                }\n\n                isActive = timeslice !== undefined;\n\n                return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n            };\n        })(nativeMediaRecorder.start);\n\n        return nativeMediaRecorder;\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}