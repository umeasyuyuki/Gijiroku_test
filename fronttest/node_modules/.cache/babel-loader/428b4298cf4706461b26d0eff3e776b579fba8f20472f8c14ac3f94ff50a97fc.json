{"ast":null,"code":"export const createRecorderAudioWorkletNodeFactory = (createListener, createPostMessage, on, validateState) => {\n  return (audioWorkletNodeConstructor, context, options = {}) => {\n    const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', {\n      ...options,\n      channelCountMode: 'explicit',\n      numberOfInputs: 1,\n      numberOfOutputs: 0\n    });\n    const ongoingRequests = new Map();\n    const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n    const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n    audioWorkletNode.port.start();\n    let state = 'inactive';\n    Object.defineProperties(audioWorkletNode, {\n      pause: {\n        get() {\n          return async () => {\n            validateState(['recording'], state);\n            state = 'paused';\n            return postMessage({\n              method: 'pause'\n            });\n          };\n        }\n      },\n      port: {\n        get() {\n          throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n        }\n      },\n      record: {\n        get() {\n          return async encoderPort => {\n            validateState(['inactive'], state);\n            state = 'recording';\n            return postMessage({\n              method: 'record',\n              params: {\n                encoderPort\n              }\n            }, [encoderPort]);\n          };\n        }\n      },\n      resume: {\n        get() {\n          return async () => {\n            validateState(['paused'], state);\n            state = 'recording';\n            return postMessage({\n              method: 'resume'\n            });\n          };\n        }\n      },\n      stop: {\n        get() {\n          return async () => {\n            validateState(['paused', 'recording'], state);\n            state = 'stopped';\n            try {\n              await postMessage({\n                method: 'stop'\n              });\n            } finally {\n              unsubscribe();\n            }\n          };\n        }\n      }\n    });\n    return audioWorkletNode;\n  };\n};","map":{"version":3,"names":["createRecorderAudioWorkletNodeFactory","createListener","createPostMessage","on","validateState","audioWorkletNodeConstructor","context","options","audioWorkletNode","channelCountMode","numberOfInputs","numberOfOutputs","ongoingRequests","Map","postMessage","port","unsubscribe","start","state","Object","defineProperties","pause","get","method","Error","record","encoderPort","params","resume","stop"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/recorder-audio-worklet/src/factories/recorder-audio-worklet-node-factory.ts"],"sourcesContent":["import type {\n    IAudioWorkletNode,\n    TAudioWorkletNodeConstructor,\n    TContext,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeConstructor,\n    TNativeContext\n} from 'standardized-audio-context';\nimport type { on as onFunction } from 'subscribable-things';\nimport type { validateState as validateStateFunction } from '../functions/validate-state';\nimport { INativeRecorderAudioWorkletNode, IRecorderAudioWorkletNode } from '../interfaces';\nimport { TAnyRecorderAudioWorkletNodeOptions, TState } from '../types';\nimport type { createListener as createListenerFunction } from './listener';\nimport type { createPostMessageFactory } from './post-message-factory';\n\nexport const createRecorderAudioWorkletNodeFactory = (\n    createListener: typeof createListenerFunction,\n    createPostMessage: ReturnType<typeof createPostMessageFactory>,\n    on: typeof onFunction,\n    validateState: typeof validateStateFunction\n) => {\n    return <T extends TContext | TNativeContext>(\n        audioWorkletNodeConstructor: T extends TContext ? TAudioWorkletNodeConstructor : TNativeAudioWorkletNodeConstructor,\n        context: T,\n        options: Partial<TAnyRecorderAudioWorkletNodeOptions<T>> = {}\n    ): T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode => {\n        type TAnyAudioWorkletNode = T extends TContext ? IAudioWorkletNode<T> : TNativeAudioWorkletNode;\n        type TAnyRecorderAudioWorkletNode = T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode;\n\n        const audioWorkletNode: TAnyAudioWorkletNode = new (<any>audioWorkletNodeConstructor)(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n\n        audioWorkletNode.port.start();\n\n        let state: TState = 'inactive';\n\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get(): TAnyRecorderAudioWorkletNode['pause'] {\n                    return async () => {\n                        validateState(['recording'], state);\n\n                        state = 'paused';\n\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get(): TAnyRecorderAudioWorkletNode['port'] {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get(): TAnyRecorderAudioWorkletNode['record'] {\n                    return async (encoderPort: MessagePort) => {\n                        validateState(['inactive'], state);\n\n                        state = 'recording';\n\n                        return postMessage(\n                            {\n                                method: 'record',\n                                params: { encoderPort }\n                            },\n                            [encoderPort]\n                        );\n                    };\n                }\n            },\n            resume: {\n                get(): TAnyRecorderAudioWorkletNode['resume'] {\n                    return async () => {\n                        validateState(['paused'], state);\n\n                        state = 'recording';\n\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get(): TAnyRecorderAudioWorkletNode['stop'] {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n\n                        state = 'stopped';\n\n                        try {\n                            await postMessage({ method: 'stop' });\n                        } finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n\n        return <TAnyRecorderAudioWorkletNode>audioWorkletNode;\n    };\n};\n"],"mappings":"AAeA,OAAO,MAAMA,qCAAqC,GAAGA,CACjDC,cAA6C,EAC7CC,iBAA8D,EAC9DC,EAAqB,EACrBC,aAA2C,KAC3C;EACA,OAAO,CACHC,2BAAmH,EACnHC,OAAU,EACVC,OAAA,GAA2D,EAAE,KACwB;IAIrF,MAAMC,gBAAgB,GAAyB,IAAUH,2BAA4B,CAACC,OAAO,EAAE,kCAAkC,EAAE;MAC/H,GAAGC,OAAO;MACVE,gBAAgB,EAAE,UAAU;MAC5BC,cAAc,EAAE,CAAC;MACjBC,eAAe,EAAE;KACpB,CAAC;IACF,MAAMC,eAAe,GAAyD,IAAIC,GAAG,EAAE;IACvF,MAAMC,WAAW,GAAGZ,iBAAiB,CAACU,eAAe,EAAEJ,gBAAgB,CAACO,IAAI,CAAC;IAC7E,MAAMC,WAAW,GAAGb,EAAE,CAACK,gBAAgB,CAACO,IAAI,EAAE,SAAS,CAAC,CAACd,cAAc,CAACW,eAAe,CAAC,CAAC;IAEzFJ,gBAAgB,CAACO,IAAI,CAACE,KAAK,EAAE;IAE7B,IAAIC,KAAK,GAAW,UAAU;IAE9BC,MAAM,CAACC,gBAAgB,CAACZ,gBAAgB,EAAE;MACtCa,KAAK,EAAE;QACHC,GAAGA,CAAA;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,WAAW,CAAC,EAAEc,KAAK,CAAC;YAEnCA,KAAK,GAAG,QAAQ;YAEhB,OAAOJ,WAAW,CAAC;cACfS,MAAM,EAAE;aACX,CAAC;UACN,CAAC;QACL;OACH;MACDR,IAAI,EAAE;QACFO,GAAGA,CAAA;UACC,MAAM,IAAIE,KAAK,CAAC,2DAA2D,CAAC;QAChF;OACH;MACDC,MAAM,EAAE;QACJH,GAAGA,CAAA;UACC,OAAO,MAAOI,WAAwB,IAAI;YACtCtB,aAAa,CAAC,CAAC,UAAU,CAAC,EAAEc,KAAK,CAAC;YAElCA,KAAK,GAAG,WAAW;YAEnB,OAAOJ,WAAW,CACd;cACIS,MAAM,EAAE,QAAQ;cAChBI,MAAM,EAAE;gBAAED;cAAW;aACxB,EACD,CAACA,WAAW,CAAC,CAChB;UACL,CAAC;QACL;OACH;MACDE,MAAM,EAAE;QACJN,GAAGA,CAAA;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,QAAQ,CAAC,EAAEc,KAAK,CAAC;YAEhCA,KAAK,GAAG,WAAW;YAEnB,OAAOJ,WAAW,CAAC;cACfS,MAAM,EAAE;aACX,CAAC;UACN,CAAC;QACL;OACH;MACDM,IAAI,EAAE;QACFP,GAAGA,CAAA;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAEc,KAAK,CAAC;YAE7CA,KAAK,GAAG,SAAS;YAEjB,IAAI;cACA,MAAMJ,WAAW,CAAC;gBAAES,MAAM,EAAE;cAAM,CAAE,CAAC;aACxC,SAAS;cACNP,WAAW,EAAE;;UAErB,CAAC;QACL;;KAEP,CAAC;IAEF,OAAqCR,gBAAgB;EACzD,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}