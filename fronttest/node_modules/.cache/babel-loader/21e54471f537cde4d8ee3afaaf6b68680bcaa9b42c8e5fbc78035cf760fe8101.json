{"ast":null,"code":"import { createBroker } from 'broker-factory';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nexport const wrap = createBroker({\n  characterize: ({\n    call\n  }) => {\n    return () => call('characterize');\n  },\n  encode: ({\n    call\n  }) => {\n    return (recordingId, timeslice) => {\n      return call('encode', {\n        recordingId,\n        timeslice\n      });\n    };\n  },\n  record: ({\n    call\n  }) => {\n    return async (recordingId, sampleRate, typedArrays) => {\n      await call('record', {\n        recordingId,\n        sampleRate,\n        typedArrays\n      }, typedArrays.map(({\n        buffer\n      }) => buffer));\n    };\n  }\n});\nexport const load = url => {\n  const worker = new Worker(url);\n  return wrap(worker);\n};","map":{"version":3,"names":["createBroker","wrap","characterize","call","encode","recordingId","timeslice","record","sampleRate","typedArrays","map","buffer","load","url","worker","Worker"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/extendable-media-recorder-wav-encoder-broker/src/module.ts"],"sourcesContent":["import { createBroker } from 'broker-factory';\nimport { TExtendableMediaRecorderWavEncoderWorkerDefinition } from 'extendable-media-recorder-wav-encoder-worker';\nimport { IExtendableMediaRecorderWavEncoderBrokerDefinition } from './interfaces';\nimport { TExtendableMediaRecorderWavEncoderBrokerLoader, TExtendableMediaRecorderWavEncoderBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const wrap: TExtendableMediaRecorderWavEncoderBrokerWrapper = createBroker<\n    IExtendableMediaRecorderWavEncoderBrokerDefinition,\n    TExtendableMediaRecorderWavEncoderWorkerDefinition\n>({\n    characterize: ({ call }) => {\n        return () => call('characterize');\n    },\n    encode: ({ call }) => {\n        return (recordingId, timeslice) => {\n            return call('encode', { recordingId, timeslice });\n        };\n    },\n    record: ({ call }) => {\n        return async (recordingId, sampleRate, typedArrays) => {\n            await call(\n                'record',\n                { recordingId, sampleRate, typedArrays },\n                typedArrays.map(({ buffer }) => buffer)\n            );\n        };\n    }\n});\n\nexport const load: TExtendableMediaRecorderWavEncoderBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,gBAAgB;AAK7C;;;;AAIA,cAAc,oBAAoB;AAClC,cAAc,eAAe;AAE7B,OAAO,MAAMC,IAAI,GAAoDD,YAAY,CAG/E;EACEE,YAAY,EAAEA,CAAC;IAAEC;EAAI,CAAE,KAAI;IACvB,OAAO,MAAMA,IAAI,CAAC,cAAc,CAAC;EACrC,CAAC;EACDC,MAAM,EAAEA,CAAC;IAAED;EAAI,CAAE,KAAI;IACjB,OAAO,CAACE,WAAW,EAAEC,SAAS,KAAI;MAC9B,OAAOH,IAAI,CAAC,QAAQ,EAAE;QAAEE,WAAW;QAAEC;MAAS,CAAE,CAAC;IACrD,CAAC;EACL,CAAC;EACDC,MAAM,EAAEA,CAAC;IAAEJ;EAAI,CAAE,KAAI;IACjB,OAAO,OAAOE,WAAW,EAAEG,UAAU,EAAEC,WAAW,KAAI;MAClD,MAAMN,IAAI,CACN,QAAQ,EACR;QAAEE,WAAW;QAAEG,UAAU;QAAEC;MAAW,CAAE,EACxCA,WAAW,CAACC,GAAG,CAAC,CAAC;QAAEC;MAAM,CAAE,KAAKA,MAAM,CAAC,CAC1C;IACL,CAAC;EACL;CACH,CAAC;AAEF,OAAO,MAAMC,IAAI,GAAoDC,GAAW,IAAI;EAChF,MAAMC,MAAM,GAAG,IAAIC,MAAM,CAACF,GAAG,CAAC;EAE9B,OAAOZ,IAAI,CAACa,MAAM,CAAC;AACvB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}