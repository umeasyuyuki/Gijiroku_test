{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n    return function (set) {\n      var number = generateUniqueNumber(set);\n      set.add(number);\n      return number;\n    };\n  };\n  var createCache = function createCache(lastNumberWeakMap) {\n    return function (collection, nextNumber) {\n      lastNumberWeakMap.set(collection, nextNumber);\n      return nextNumber;\n    };\n  };\n\n  /*\n   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n   * is fairly new.\n   */\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n  var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n  var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n  var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n    return function (collection) {\n      var lastNumber = lastNumberWeakMap.get(collection);\n      /*\n       * Let's try the cheapest algorithm first. It might fail to produce a new\n       * number, but it is so cheap that it is okay to take the risk. Just\n       * increase the last number by one or reset it to 0 if we reached the upper\n       * bound of SMIs (which stands for small integers). When the last number is\n       * unknown it is assumed that the collection contains zero based consecutive\n       * numbers.\n       */\n      var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n      if (!collection.has(nextNumber)) {\n        return cache(collection, nextNumber);\n      }\n      /*\n       * If there are less than half of 2 ** 30 numbers stored in the collection,\n       * the chance to generate a new random number in the range from 0 to 2 ** 30\n       * is at least 50%. It's benifitial to use only SMIs because they perform\n       * much better in any environment based on V8.\n       */\n      if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n        }\n        return cache(collection, nextNumber);\n      }\n      // Quickly check if there is a theoretical chance to generate a new number.\n      if (collection.size > MAX_SAFE_INTEGER) {\n        throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n      }\n      // Otherwise use the full scale of safely usable integers.\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n      }\n      return cache(collection, nextNumber);\n    };\n  };\n  var LAST_NUMBER_WEAK_MAP = new WeakMap();\n  var cache = createCache(LAST_NUMBER_WEAK_MAP);\n  var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n  var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n  exports.addUniqueNumber = addUniqueNumber;\n  exports.generateUniqueNumber = generateUniqueNumber;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","fastUniqueNumbers","createAddUniqueNumber","generateUniqueNumber","set","number","add","createCache","lastNumberWeakMap","collection","nextNumber","MAX_SAFE_INTEGER","Number","undefined","TWO_TO_THE_POWER_OF_TWENTY_NINE","TWO_TO_THE_POWER_OF_THIRTY","createGenerateUniqueNumber","cache","lastNumber","get","size","has","Math","floor","random","Error","LAST_NUMBER_WEAK_MAP","WeakMap","addUniqueNumber"],"sources":["/Users/asyuyukiume/AI学習/議事録　テスト/fronttest/node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es5/bundle.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n          return cache(collection, nextNumber);\n        }\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}